<html>
  <body>
    <h1>Digit ML</h1>
    <div>
      <h3>Current data:</h3>
      <ul>
      <% _.forEach(data, function(digit) { %>
        <li>digit {{ digit.digit }}: {{ digit.count }} rows</li>
      <% }); %>
      </ul>
      <div>Random samples:</div>
      <div id="samples"></div>
    </div>
    <p>
      Draw a
      <select id="digit"></select>
      in the box below:
    </p>
    <div>
      <canvas id="feeder" width="50" height="50" style="outline-width: 1px; outline-style: solid;"></canvas>
    </div>
    <br />
    <button id="clear">Clear</button>
    <button id="save">Save & clear</button>
    <a href="#" id="download" onclick="downloadMat()">Download as matrix</a>
    <script>
      const digitSelect = document.getElementById('digit');
      for (let i = 0; i < 10; i += 1) {
        const option = document.createElement('option');
        option.setAttribute('value', i);
        option.innerText = i;
        digitSelect.appendChild(option);
      }

      const feed = async (digit, imgData) => {
        const response = await fetch('/feed', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ digit, imgData }),
        });
      };

      const createCanvasElement = (id) => {
        const elem = document.createElement('canvas');
        elem.setAttribute('id', id);
        elem.setAttribute('width', 50);
        elem.setAttribute('height', 50);
        elem.setAttribute('style', 'outline-width: 1px; outline-style: solid; margin: 10px;');
        return elem;
      };

      const convertCanvasToGrayscale = (context, dimensions) => {
        const grayscale = [];
        for (let i = 0; i < dimensions.width; i += 1) {
          grayscale[i] = [];
          for (let j = 0; j < dimensions.height; j += 1) {
            const pixel = context.getImageData(j, i, 1, 1);
            grayscale[i][j] = pixel.data[3];
          }
        }
        return grayscale;
      };

      const grayscaleToText = (grayscale) => {
        let matrixText = '';
        for (let i = 0; i < grayscale.length; i += 1) {
          const row = grayscale[i];
          for (let j = 0; j < row.height; j += 1) {
            matrixText = `${matrixText}${row[j]} `;
          }
          matrixText = `${matrixText}\n`;
        }
        return matrixText;
      };

      const fillImage = (data, elem) => {
        const sampleRect = elem.getBoundingClientRect();
        const sampleCtx = elem.getContext('2d');
        // rebuild rgba array
        let array = [];

        for(let i = 0; i < data.length; i += 1) {
          const row = data[i];
          for (let j = 0; j < row.length; j += 1) {
            array = array.concat([0, 0, 0, row[j]]);
          }
        }
        const pix = Uint8ClampedArray.from(array);
        const imgData = new ImageData(pix, sampleRect.width, sampleRect.height);
        sampleCtx.putImageData(imgData, 0, 0);
      };

      const draw = (ctx, x, y) => {
        if (ctx && drawing) {
          ctx.beginPath();
          ctx.strokeStyle = 'black';
          ctx.lineWidth = 1;
          ctx.lineJoin = "round";
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(x, y);
          ctx.closePath();
          ctx.stroke();
        }
        lastX = x; lastY = y;
      };

      const samples = {{ samples }};
      const sampleContainer = document.getElementById('samples');
      for (let sample of samples) {
        const sampleElement = createCanvasElement(`sample-${sample.id}`);
        sampleContainer.appendChild(sampleElement);
        fillImage(sample.image, sampleElement);
      }

      const canvas = document.getElementById('feeder');
      const save = document.getElementById('save');
      const download = document.getElementById('download');
      const rect = canvas.getBoundingClientRect();
      const canvasCtx = canvas.getContext('2d');
      let drawing = false;
      let lastX;
      let lastY;
      canvas.addEventListener('mousedown', e => {
        x = Math.floor(e.clientX - rect.left);
        y = Math.floor(e.clientY - rect.top);
        drawing = true;
        draw(canvasCtx, x, y);
      });
      canvas.addEventListener('mouseup', e => {
        drawing = false;
      });
      canvas.addEventListener('mouseleave', e => {
        drawing = false;
      });
      canvas.addEventListener('mousemove', e => {
        x = Math.floor(e.clientX - rect.left);
        y = Math.floor(e.clientY - rect.top);
        draw(canvasCtx, x, y);
      });

      clear.onclick = () => {
        canvasCtx.clearRect(0, 0, rect.width, rect.height);
      };
      save.onclick = async () => {
        const grayscale = convertCanvasToGrayscale(canvasCtx, rect);
        const digit = digitSelect.value;
        await feed(digit, grayscale);
        canvasCtx.clearRect(0, 0, rect.width, rect.height);
      };

      const downloadMat = () => {
        const grayscale = convertCanvasToGrayscale(canvasCtx, rect);
        download.href = 'data:attachment/text,' + encodeURI(grayscaleToText(grayscale));
        download.target = '_blank';
        download.download = 'imgMatrix.dat';
        download.click();
      };
    </script>
  </body>
</html>
